#day 07

배열의 정령

	치환정렬을 해서 정렬을 한다.
	이 때 방법은
	처음부터 하나씩 꺼내고
	비교를 하는데 대상은 꺼낸 다음 데이터부터 끝까지 꺼내서 비교를 해서
	오름차순이라면 
		대상이 더 작다면 현재 데이터와 교체를 해줘야 한다.
	이때 주의상항은
	현재 데이터에 데이터를 입력하는 순간
	기존 데이터는 사라질 것이고 찾을 방법이 없다.
	따라서 사라지기 전에 어딘가에 저장을 해둬야 한다.
----------------------------------------------------------------------------
#flag 기법

	==> 프로그램을 실행하다 보면 
		두가지 이상의 경우가 발생되는 순간이 존재한다.	
		그 후에 어떤 경우가 발생이 되서 처리된 것인지 알아보는 기법
		
		예]
			for() {
				break; // 이명령이 실행이 되면 (1)이 실행이된다.
				}
				
				(1)
				==> 부분은 for명령이 정상적으로 종료된 후에 실행되는 부분이다.
				
				문제]
					(1) 부분은 실행할때 정상적으로 종료되었는지?
					break; 명령을 만나서 종료되었는지??
					알수없다.
					
				방법]
					시작하기 전에 변수에 특정 데이터로 초기화를 시켜놓고
					특정 순간이 발생하면 변수의 데이터를 변경시킨다.
					(break 되기 전에  ...)
					
					(1) 번 부분에서는 변수의 값에 따라서
					반복문이 정상적으로 모두 실행이 되었는지
					아니면 중간에 중단이 되었는지 판단 할 수 있게 된다.
----------------------------------------------------------------------------------

배열의 복사
	
	1. 얕은 복사
		==> 주소만 복사해주는 기법
			
			특징]
				데이터는 공유하므로 한 고에서 수정하면
				다른곳에서도 수정된 데이터를 사용하게된다.
			복사방법]
				int[] num1 = new int[5]
				....
				int[] num2; - 이것은 배열 주소를 기억할 변수를 만들어 주는거
							  num2안에는 데이터는 기억할 수 없고
							    오직 주소만 기억할수 있다.
				num2 = num1;	==> 얕은 복사
				
			참고]
				얕은 복사는
				지역변수는 그 지역에서만(해당 블럭에서만) 활동하므로
				다른 지역에서 Heap 영역의 데이터를 사용할 목적으로 많이 사용되는 기법.	
				
				다른 지역에서 만든 Heap 영역의 데이터를
				다른 지역에서도 같이 사용할 목적으로 많이 사용되는 기법이다.
	2. 깊은 복사					
		==> 데이터 까지 모두 복사해주는 기법
			==> 데이터가 복사되는 것은
				Heap 영역에 다른곳에서 데이터가 한번더 존재한다는 의미이므로
				데이터의 주소가 달라지게 되므로 
				
			특징]
				복사된 데이터는 독립적으로 사용 된다.
				
			명령]
				System.arraycopy(#1, #2, #3, #4, #5);
					
					#1 - 원본 데이터의 주소
					#2 - 원본 데이터의 복사를 시작할 위치
					#3 - 복사받을 배열의 주소
					#4 - 복사받을 배열의 입력 시작위치
					#5 - 복사받을 데이터의 갯수
-----------------------------------------------------------------------------------

배열의 단점
 	1. 한번 배열의 크기를 정하면 크기 조절이 불가능하다.
 		예]
 			int[] num = new int[10];
 			//정수 데이터를 10개 관리할 예정이다.
 			//이때 정수 데이터가 11개를 관리를 해야된다면???
 			//원칙적으로 불가능하다
 			//이때 해결 방법은 깊은 복사를 해준다.
 			
 			int[] num2 = new int[20];
 			//num2의 앞부분에 깊은 복사로 데이터를 채워 넣으면
 			//이후 10개를 더 저장해서 사용할수 있게 된다.
 	2. 같은 타입의 데이터만 입력할 수있다.
 		
 		==> 주는 Heap Type에 의해서 결정되고
 			Heap Type이 다르면 사용할수 없다.(호환이 안된다)
 			
 		예]
 			int[] no = new int[10];
 			
 			float[] no2;
 			
 			no2 = no;
 			
 ------------------------------------------------------------------------------
  String 배열
  	
  	참고]
  		String 역시 첨조형 변수이다. 주소를 기억하고 있다.
  		
  		String str = "hong";
  		이라고 정의를 하면
  		
  		str 속에는 Heap에 만들어진 주소를 기억을 하고 있다.
  		"hong" 리터럴 풀에 기억 된다.
  	
  	참고]
  		문자열 만드는 방법1]
  			String 변수이름 = "데이터";
  			
  		문자열 만드는 방법2]
 			String 변수이름 = new String(문자열데이터);
 	***
 	문자열은 변경이 자주 일어나는 문자열의 경우
 	String 타입으로 만들지 않고
 	StringBuffer 나 StringBuild타입으로 만들고 연해서
 	최종적으로 변경된 데이터를 String 타입으로 사용하는 것이 좋다.		
--------------------------------------------------------------------------------

반장님 문제]
	45 ~ 1 까지 저장할 배열을 만들고
	배열에서 로또 번호를 꺼내서 로또 한게임을 만들고 출력하세요
-----------------------------------------------------------------------------

문제1]
	알파벳 10개를 저장할 배열을 만들고
	대문자 10개를 랜덤하게 추출해서 배열에 저장하고
	저장된 배열을 얕은 복사로 복사해서
	출력하고
	원래 배열을 소문자로 변경한 후 
	두 배열을 출력하세요.
-----------------------------------------------------------------------------
문제2]
	정수 10개를 저장할 배열을 만들고
	랜덤하게 정수를 1 ~ 50까지 수중 발생시켜서 
	배열에 담고 
	배열의 5번째까지의 데이터를 깊은 복사로 복사하세요
----------------------------------------------------------------------------
문제3]
	회원의 이름, 전화번호, 이메일을 저장할 배열을 만들고
	데이터를 입력해 놓고
	이름을 입력하면 
	그 사람의 데이터를 모두 저장할 배열을 만들어서 데이터를 넣고 출력하세요
-----------------------------------------------------------------------------
 문제4]
 	전화번호를 입력하면
 	'-'를 기준으로 데이터를 분리를 해서 
 	저장할 배열을 만들고 분리된 데이터를 순서에 맞게 입력하고 출력하세요.
 	indexOf()
 	substring()
 ---------------------------------------------------------------------------
extra]
	영문 문자열을 입력받아서
	해당 알파벳이 출현하는 빈도를 저장하고
	빈도를 *로 표현하세요
----------------------------------------------------------------------------- 	